name: Docker
on:
  schedule:
    - cron: '0 18 * * *'
  workflow_dispatch:
  push:
    branches: [ main ]
env:
  ALIYUN_REGISTRY: "${{ secrets.ALIYUN_REGISTRY }}"
  ALIYUN_NAME_SPACE: "${{ secrets.ALIYUN_NAME_SPACE }}"
  ALIYUN_REGISTRY_USER: "${{ secrets.ALIYUN_REGISTRY_USER }}"
  ALIYUN_REGISTRY_PASSWORD: "${{ secrets.ALIYUN_REGISTRY_PASSWORD }}"
jobs:
  build:
    name: Pull and Push
    runs-on: ubuntu-latest
    steps:
    - name: Initial disk status
      run: |
        echo "初始磁盘状态："
        echo "=============================================================================="
        df -h
        echo "磁盘使用情况："
        df -h | grep -E 'Filesystem|/dev/'
        echo "------------------------------------------------------------------------------"
        echo "Docker 磁盘使用："
        docker system df || true
        echo "=============================================================================="
    
    # 第一步：彻底清理所有Docker资源
    - name: Deep clean Docker BEFORE starting
      run: |
        echo "开始深度清理Docker缓存和镜像..."
        echo "=============================================================================="
        
        # 1. 停止所有正在运行的容器
        echo "停止所有容器..."
        docker stop $(docker ps -q) 2>/dev/null || echo "没有正在运行的容器"
        
        # 2. 删除所有容器
        echo "删除所有容器..."
        docker rm -f $(docker ps -aq) 2>/dev/null || echo "没有可删除的容器"
        
        # 3. 删除所有镜像
        echo "删除所有镜像..."
        docker rmi -f $(docker images -q) 2>/dev/null || echo "没有可删除的镜像"
        
        # 4. 删除所有卷
        echo "删除未使用的卷..."
        docker volume rm $(docker volume ls -q) 2>/dev/null || echo "没有可删除的卷"
        
        # 5. 清理所有Docker系统资源
        echo "清理Docker系统资源..."
        docker system prune -a -f --volumes
        
        # 6. 清理builder缓存
        echo "清理builder缓存..."
        docker builder prune -a -f
        
        # 7. 清理网络
        echo "清理未使用的网络..."
        docker network prune -f
        
        echo "------------------------------------------------------------------------------"
        echo "清理后的Docker状态："
        docker system df || true
        echo "=============================================================================="
        
        # 8. 清理系统缓存
        echo "清理系统缓存..."
        sudo sync
        sudo sh -c 'echo 3 > /proc/sys/vm/drop_caches' 2>/dev/null || true
        
        # 9. 清理临时文件
        echo "清理临时文件..."
        sudo rm -rf /tmp/* /var/tmp/* 2>/dev/null || true
        sudo rm -rf /home/runner/.cache/* 2>/dev/null || true
        
        echo "清理完成后的磁盘状态："
        df -h | grep -E 'Filesystem|/dev/'
    
    - name: Maximize build space
      uses: easimon/maximize-build-space@master
      with:
        root-reserve-mb: 1024
        swap-size-mb: 1024  # 增加交换空间
        remove-dotnet: 'true'
        remove-haskell: 'true'
        remove-android: 'true'
        remove-codeql: 'true'
        remove-docker-images: 'true'
        remove-python: 'true'  # 除非你需要Python
        remove-node: 'false'   # 根据需求调整
        build-mount-path: '/var/lib/docker/'
        
    - name: Restart docker with clean state
      run: |
        echo "重启Docker服务..."
        sudo service docker stop 2>/dev/null || true
        sudo service docker start
        sleep 5
        echo "Docker重启完成"
        
    - name: Checkout Code
      uses: actions/checkout@v4
      
    - name: Docker Setup Buildx
      uses: docker/setup-buildx-action@v3
      
    - name: Build and push images with incremental cleanup
      run: |
        # 登录到阿里云
        docker login -u $ALIYUN_REGISTRY_USER -p $ALIYUN_REGISTRY_PASSWORD $ALIYUN_REGISTRY
        
        echo "=============================================================================="
        echo "开始处理镜像列表，当前磁盘状态："
        df -h | grep -E 'Filesystem|/dev/'
        echo "=============================================================================="
        
        # 创建备份文件
        cp images.txt images_processed.txt
        
        # 数据处理逻辑（保持不变）
        declare -A duplicate_images
        declare -A temp_map
        
        # 第一次读取：识别重复的镜像名
        while IFS= read -r line || [ -n "$line" ]; do
            [[ -z "$line" ]] && continue
            if echo "$line" | grep -q '^\s*#'; then
                continue
            fi
            
            image=$(echo "$line" | awk '{print $NF}')
            image="${image%%@*}"
            image_name_tag=$(echo "$image" | awk -F'/' '{print $NF}')
            name_space=$(echo "$image" | awk -F'/' '{if (NF==3) print $2; else if (NF==2) print $1; else print ""}')
            name_space="${name_space}_"
            image_name=$(echo "$image_name_tag" | awk -F':' '{print $1}')
            
            if [[ -n "${temp_map[$image_name]}" ]]; then
                 if [[ "${temp_map[$image_name]}" != $name_space ]]; then
                    duplicate_images[$image_name]="true"
                 fi
            else
                temp_map[$image_name]=$name_space
            fi       
        done < images_processed.txt
        
        # 第二次读取：处理每个镜像
        counter=0
        processed=0
        failed_images=()
        
        while IFS= read -r line || [ -n "$line" ]; do
            [[ -z "$line" ]] && continue
            if echo "$line" | grep -q '^\s*#'; then
                continue
            fi
            
            counter=$((counter+1))
            original_line="$line"
            
            echo ""
            echo "=============================================================================="
            echo "处理第 $counter 个镜像: $line"
            echo "=============================================================================="
            
            # 在处理前检查磁盘空间
            echo "处理前磁盘状态："
            df -h | grep -E 'Filesystem|/dev/'
            
            # 拉取镜像
            echo "拉取镜像..."
            if docker pull $line; then
                echo "✓ 拉取成功"
                processed=$((processed+1))
            else
                echo "✗ 拉取失败: $line"
                failed_images+=("$line")
                
                # 拉取失败时尝试清理
                echo "拉取失败，尝试清理后重试..."
                docker system prune -f
                sleep 2
                
                # 重试一次
                if docker pull $line; then
                    echo "✓ 重试拉取成功"
                    processed=$((processed+1))
                else
                    echo "✗ 重试也失败，跳过此镜像"
                    continue
                fi
            fi
            
            # 处理平台信息
            platform=$(echo "$line" | awk -F'--platform[ =]' '{if (NF>1) print $2}' | awk '{print $1}')
            if [ -z "$platform" ]; then
                platform_prefix=""
            else
                platform_prefix="${platform//\//_}_"
            fi
            
            # 获取镜像信息
            image=$(echo "$line" | awk '{print $NF}')
            image_name_tag=$(echo "$image" | awk -F'/' '{print $NF}')
            name_space=$(echo "$image" | awk -F'/' '{if (NF==3) print $2; else if (NF==2) print $1; else print ""}')
            image_name=$(echo "$image_name_tag" | awk -F':' '{print $1}')
            image_name_tag="${image_name_tag%%@*}"
            
            # 处理命名空间前缀
            name_space_prefix=""
            if [[ -n "${duplicate_images[$image_name]}" ]]; then
               if [[ -n "${name_space}" ]]; then
                  name_space_prefix="${name_space}_"
               fi
            fi
            
            # 构建新镜像名
            new_image="$ALIYUN_REGISTRY/$ALIYUN_NAME_SPACE/$platform_prefix$name_space_prefix$image_name_tag"
            
            # 打标签
            echo "打标签: $image -> $new_image"
            docker tag $image $new_image
            
            # 推送
            echo "推送镜像..."
            docker push $new_image
            echo "✓ 推送成功"
            
            # 立即清理已处理的镜像
            echo "清理镜像释放空间..."
            docker rmi -f $image $new_image 2>/dev/null || true
            
            # 每处理3个镜像进行一次轻度清理
            if [ $((processed % 3)) -eq 0 ]; then
                echo "每3个镜像执行一次清理..."
                docker system prune -f
                docker builder prune -f
            fi
            
            # 每处理6个镜像进行一次深度清理
            if [ $((processed % 6)) -eq 0 ]; then
                echo "每6个镜像执行深度清理..."
                docker system prune -a -f
                sudo sync
                sudo sh -c 'echo 1 > /proc/sys/vm/drop_caches' 2>/dev/null || true
            fi
            
            echo "处理后磁盘状态："
            df -h | grep -E 'Filesystem|/dev/'
            
            # 标记已处理的镜像
            sed -i "/^$(echo "$original_line" | sed 's/[\/&]/\\&/g')$/d" images_processed.txt
            
        done < images.txt
        
        echo ""
        echo "=============================================================================="
        echo "镜像处理完成统计："
        echo "总共尝试处理: $counter 个镜像"
        echo "成功处理: $processed 个镜像"
        
        if [ ${#failed_images[@]} -gt 0 ]; then
            echo "失败的镜像:"
            for failed in "${failed_images[@]}"; do
                echo "  - $failed"
            done
        fi
        
        echo "最终磁盘状态："
        df -h | grep -E 'Filesystem|/dev/'
        echo "=============================================================================="
    
    - name: Final cleanup after all processing
      if: always()
      run: |
        echo "=============================================================================="
        echo "最终清理阶段..."
        echo "=============================================================================="
        
        # 最终深度清理
        docker system prune -a -f --volumes
        docker builder prune -a -f
        docker container prune -f
        docker volume prune -f
        docker network prune -f
        
        # 清理临时文件
        sudo rm -rf /tmp/* /var/tmp/* /home/runner/.cache/*
        
        echo "最终磁盘状态："
        df -h | grep -E 'Filesystem|/dev/'
        
        echo "最终Docker状态："
        docker system df 2>/dev/null || echo "Docker不可用"
        
        echo "清理完成！"
        echo "=============================================================================="
